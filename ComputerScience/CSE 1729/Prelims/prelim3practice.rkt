;a
(define (num->list n)
  (if (< n 10)
      (list n)
      (append (num->list (floor (/ n 10)))
              (list (- n (* 10 (floor (/ n 10))))))))
(num->list 256)
;b
(define (sos l)
  (if (null? l)
      0
      (+ (* (car l) (car l)) (sos (cdr l)))))
(sos '(3 3 3))
;c
;given
(define (make-tree value left right)
  (list value left right))
(define (value T) (car T))
(define (left T) (cadr T))
(define (right T) (caddr T))

(define (element? x T)
  (cond ((null? T) #f)
        ((= (value T) x) #t)
        ((> x (value T)) (element? x (right T)))
        ((< x (value T)) (element? x (left T)))))

(define (insert x T)
  (cond ((null? T) (make-tree x '() '()))
        ((eq? x (value T)) T)
        ((> x (value T)) (make-tree (value T)
                                    (left T)
                                    (insert x (right T))))
        ((< x (value T)) (make-tree (value T)
                                    (insert x (left T))
                                    (right T)))))
;d
(define (is-happy? x)
  (define (hap-help x s)
    (let* ((iter (sos (num->list x))))
      (cond ((= 1 iter) #t)
            ((element? iter s) #f)
            (else (hap-help iter (insert iter s))))))
  (hap-help x '()))
(is-happy? 379)
;e
(define (prime? n)
  (define (divisor? k) (= 0 (modulo n k)))
  (define (divisors-upto k)
    (and (> k 1)
         (or (divisor? k) (divisors-upto (- k 1)))))
  (not (divisors-upto (- n 1))))

(define (happy-prime? n)
  (if (and (prime? n) (is-happy? n))
      #t
      #f))
;f
(define (happy-primes n)
  (define (hp-help n cur)
    (cond ((= n 0) '())
          ((happy-prime? cur) (append
                              (list cur)
                              (hp-help (- n 1) (+ cur 1))))
          (else (hp-help n (+ cur 1)))))
  (hp-help n 7))
(happy-primes 4)
;g
(define (head s) (car s))
(define (rest s) (force (cdr s)))
(define empty? null?)

(define (happy-primes)
  (define (find-next text n)
    (define (find-aux x)
      (cond ((test x) x)
            (else (find-aux (+ x 1)))))
    (find-aux n))
  (define (happy-primes-aux n)
    (cons n
          (delay (happy-primes-aux (find-next happy-prime? (+ n 1))))))
  (happy-primes-aux 7))
;h
(define (make-happy-primes)
  (let ((hp 7))
    (define (num->list n)
      (if (< n 10)
          (list n)
          (append (num->list (floor (/ n 10)))
                  (list (- n (* 10 (floor (/ n 10))))))))
    (define (sos l)
      (if (null? l)
          0
          (+ (* (car l) (car l)) (sos (cdr l)))))
    (define (make-tree value left right)
      (list value left right))
    (define (value T) (car T))
    (define (left T) (cadr T))
    (define (right T) (caddr T))

    (define (element? x T)
      (cond ((null? T) #f)
            ((= (value T) x) #t)
            ((> x (value T)) (element? x (right T)))
            ((< x (value T)) (element? x (left T)))))

    (define (insert x T)
      (cond ((null? T) (make-tree x '() '()))
            ((eq? x (value T)) T)
            ((> x (value T)) (make-tree (value T)
                                        (left T)
                                        (insert x (right T))))
            ((< x (value T)) (make-tree (value T)
                                        (insert x (left T))
                                        (right T)))))
    (define (is-happy? x)
      (define (hap-help x s)
        (let* ((iter (sos (num->list x))))
          (cond ((= 1 iter) #t)
                ((element? iter s) #f)
                (else (hap-help iter (insert iter s))))))
      (hap-help x '()))
    (define (prime? n)
      (define (divisor? k) (= 0 (modulo n k)))
      (define (divisors-upto k)
        (and (> k 1)
             (or (divisor? k) (divisors-upto (- k 1)))))
      (not (divisors-upto (- n 1))))

    (define (happy-prime? n)
      (if (and (prime? n) (is-happy? n))
          #t
          #f))
    (define (find-next test n)
      (define (find-aux x)
        (cond ((test x) x)
              (else (find-aux (+ x 1)))))
      (find-aux n))
    ;;pub methods
    (define (empty?) (null? hp))
    (define (head) hp)
    (define (rest) (begin (set! hp (find-next happy-prime? (+ hp 1)))
                          hp))
    ;dispatch
    (lambda (method)
      (cond ((eq? method 'empty?) empty?)
            ((eq? method 'head) head)
            ((eq? method 'rest) rest)))))

