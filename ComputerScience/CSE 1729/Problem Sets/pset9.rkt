;1
(define (nts x)
  (number->string x))
(define (f x)
  (floor x))
(define (make-clock h m)
  (let ((mins (+ (* h 60) m)))
    (define (tick)
      (if (= mins 1439)
          (set! mins 0)
          (set! mins (+ mins 1))))
    (define (military)
      (cond ((and (< mins 600) (> 10 (modulo mins 60)))
             (string-append "0" (nts (f (/ mins 60))) ":0" (nts (modulo mins 60)) "\n"))
            ((< mins 600)
             (string-append "0" (nts (f (/ mins 60))) ":" (nts (modulo mins 60)) "\n"))
            ((> 10 (modulo mins 60))
             (string-append (nts (f (/ mins 60))) ":0" (nts (modulo mins 60)) "\n"))))
    (define (time)
      (cond ((and (< mins 60) (> 10 (modulo mins 60)))
             (string-append "12:0" (nts (modulo mins 60)) " AM\n"))
            ((< mins 60)
             (string-append "12:" (nts (modulo mins 60)) " AM\n"))
            ((and (< mins 720) (> 10 (modulo mins 60)))
             (string-append (nts (f (/ mins 60))) ":0" (nts (modulo mins 60)) " AM\n"))
            ((< mins 720)
             (string-append (nts (f (/ mins 60))) ":" (nts (modulo mins 60)) " AM\n"))
            ((> 10 (modulo mins 60))
             (string-append (nts (f (/ (- mins 720) 60))) ":0" (nts (modulo mins 60)) " PM\n"))
            (else
             ((nts (f (/ (- mins 720) 60))) ":" (modulo mins 60) " PM\n"))))
    (define (dispatcher method)
      (cond ((eq? method 'time) time)
            ((eq? method 'military) military)
            ((eq? method 'tick) tick)))
    dispatcher))
(define clock (make-clock 23 59))
((clock 'tick))
((clock 'time))
((clock 'military))
((clock 'tick))
((clock 'time))
((clock 'military))
((clock 'tick))
((clock 'time))
;2
(define (make-stack)
  (let ((S ' ()))
    (define (empty?) (null? S))
    (define (top) (car S))
    (define (pop) (let ((top (car S)))
                    (begin (set! S (cdr S))
                           top)))
    (define (push x) (set! S (cons x S)))
    (define (dispatcher method)
      (cond ((eq? method 'top) top)
            ((eq? method 'pop) pop)
            ((eq? method 'push) push)
            ((eq? method 'empty?) empty?)))
    dispatcher))
;3
(define (eval-postfix p)
  (let ((stack (make-stack)) (temp p))
    (define (eval-help p)
      (let ((second ((stack 'pop))) (first ((stack 'pop))))
        (cond ((eq? p #\*) ((stack 'push) (* first second)))
              ((eq? p #\/) ((stack 'push) (/ first second)))
              ((eq? p #\+) ((stack 'push) (+ first second)))
              ((eq? p #\-) ((stack 'push) (- first second)))
              ((eq? p #\^) ((stack 'push) (expt first second))))))
    (define (tester)
      (cond ((null? temp) ((stack 'top)))
            ((number? (car temp)) (begin ((stack 'push) (car temp)) (set! temp (cdr temp)) (tester)))
            (else (begin (eval-help (car temp)) (set! temp (cdr temp)) (tester)))))
    (if (and (null? p))
        '()
        (tester))))
(eval-postfix (list 2 3 #\+))

;4
;helpers
(define (make-tree value left right) (list value left right))
(define (value tree) (car tree))
(define (left tree) (cadr tree))
(define (right tree) (caddr tree))

(define (DFS T)
  (let ((stack (make-stack)))
    (define (helper)
      (if ((stack 'empty?))
          '()
          (let ((curT ((stack 'pop))))
            (cond ((null? curT) '())
                  ((not (and (null? (right curT)) (null? (left curT))))
                   (begin ((stack 'push) (right curT))
                          ((stack 'push) (left curT))
                          (cons (value curT) (helper))))
                  ((not (null? (right curT)))
                   (begin ((stack 'push) (right curT))
                          (cons (value curT) (helper))))
                  ((not (null? (left curT)))
                   (begin ((stack 'push) (left curT))
                          (cons (value curT) (helper))))
                  ((and (null? (left curT)) (null? (right curT)))
                   (cons (value curT) (helper)))))))
    (begin ((stack 'push) T) (helper))))
(dfs '(1 (2 (3 (4 () ()) (5 () ())) (6 (7 () ()) (8 () ()))) (9 (10 (11 () ()) (12 () ())) (13 (14 () ()) (15 () ())))))

;5
(define (make-queue)
  (let ((head '())
        (tail '()))
    (define (value n) (car n))
    (define (next n) (cdr n))
    (define (empty?) (null? head))
    (define (front) (value head))
    (define (enqueue x)
      (let ((new-node (cons x '())))
        (begin
          (if (empty?)
              (set! head new-node)
              (set-cdr! tail new-node))
          (set! tail new-node))))
    (define (dequeue)
      (let ((return (value head)))
        (if (eq? head tail)
            (begin (set! head '())
                   (set! tail '())
                   return)
            (begin (set! head (next head))
                   return))))
    (define (dispatcher method)
      (cond ((eq? method 'empty) empty?)
            ((eq? method 'enqueue) enqueue)
            ((eq? method 'dequeue) dequeue)
            ((eq? method 'front) front)))
    dispatcher))

(define (bfs T)
  (let ((que (make-queue)))
    (define (help)
      (if ((que 'empty))
          '()
          (let ((node ((que 'dequeue))))
            (cond ((null? node) '())
                  ((not (and (null? (right node)) (null? (left node))))
                   (begin ((que 'enqueue) (left node))
                          ((que 'enqueue) (right node))
                          (cons (value node) (help))))
                  ((not (null? (right node)))
                   (begin ((que 'enqueue) (right node))
                          (cons (value node) (help))))
                  ((not (null? (left node)))
                   (begin ((que 'enqueue) (left node))
                          (cons (value node) (help))))
                  ((and (null? (left node)) (null? (right node)))
                   (cons (value node) (help)))))))
    (begin ((que 'enqueue) T) (help))))
(bfs '(1 (2 (3 (4 () ()) (5 () ())) (6 (7 () ()) (8 () ()))) (9 (10 (11 () ()) (12 () ())) (13 (14 () ()) (15 () ())))))
